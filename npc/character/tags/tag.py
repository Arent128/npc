from collections import UserList
from copy import copy

class Tag(UserList):
    """
    Defines a mult-value tag object
    """
    def __init__(self, name: str, *args, required: bool=False, hidden: bool=False, limit: int=-1):
        """
        Create a new Tag object

        Args:
            name (str): This tag's name
            args (str): Initial values to populate for this tag
            required (bool): Whether this tag must be present for the character
                to be valid.
            hidden (bool): Whether this tag should be displayed in character
                listings. When present, a coresponding @hide tag will be
                generated by to_header.
            limit (int): Maximum number of values allowed in the tag. Passing a
                negative number allows an infinite number of values to be
                stored.
        """
        self.name = name
        self.required = required
        self.hidden = hidden
        self.limit = limit
        self.problems = []

        super().__init__(args)

    def __repr__(self):
        return "{}({}, {}, required={}, hidden={}, limit={})".format(
            type(self).__name__,
            self.name,
            *self.data,
            self.required,
            self.hidden,
            self.limit
        )

    @property
    def present(self):
        """
        bool: Whether this tag is meaningfully present in the character

        True whenever the tag has data
        """
        return len(self.data) > 0

    @property
    def valid(self):
        """
        bool: Whether this tag is internally valid

        This property is only meaningful after calling validate()
        """
        return len(self.problems) == 0

    def validate(self, strict: bool=False):
        """
        Validate this tag's attributes

        Validations:
            * If required is set, at least one value must be present
            * Required is incompatible with a limit of zero
            * (strict) If limit is non-negative, the total values must be <= limit

        Args:
            strict (bool): Whether to report non-critical errors and omissions

        Returns:
            True if this tag has no validation problems, false if not
        """
        self.problems = []

        if self.required and not self.present:
            self.problems.append("No values for tag '{}'".format(self.name))

        if self.required and self.limit == 0:
            self.problems.append("Tag '{}' is required but limited to zero values".format(self.name))

        if strict:
            if self.limit > -1 and len(self.data) > self.limit:
                self.problems.append("Too many values for tag '{}'. Limit of {}".format(self.name, self.limit))

        return self.valid

    def to_header(self):
        """
        Generate a text header representation of this tag

        This creates the appropriate `@tag value` lines that, when parsed, will
        recreate the data of this tag. If the tag is marked as hidden, an
        additional `@hide tag` will be appended. If `.present` is false, an
        empty string is returned.

        Returns:
            A string of the header lines needed to create this tag, or an empty
            string if the present is false.
        """
        if not self.present:
            return ''

        header_lines = []
        for val in self.data:
            header_lines.append("@{} {}".format(self.name, val))

        if self.hidden:
            header_lines.append("@hide {}".format(self.name))

        return "\n".join(header_lines)

    def tagslice(self, start, stop):
        """
        Create a new tag with a slice of our data

        This applies a basic slice operation to the stored values and creates a
        copy of this tag object whose data is the new slice. This is primarily
        useful for generating limited headers.

        Args:
            start (int|None): First index included in the slice
            stop (int|None): Index to end the slice, not included in the slice itself

        Returns:
            Tag object containing the sliced values
        """
        new_tag = copy(self)
        new_tag.data = self.data[start:stop]
        return new_tag

    def first(self):
        """
        Get a copy of this tag containing only the first value

        Convenience method that's identical to calling `tagslice(0, 1)`

        Returns:
            Tag object containing the first value
        """
        return self.tagslice(0, 1)

    def remaining(self):
        """
        Get a copy of this tag excluding the first value

        Convenience method that's identical to calling `tagslice(1, None)`

        Returns:
            Tag object excluding the first value
        """
        return self.tagslice(1, None)
